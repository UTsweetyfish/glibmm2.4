<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>glibmm: Glib::MainContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.66.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1MainContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::MainContext Class Reference<div class="ingroups"><a class="el" href="group__MainLoop.html">The Main Event Loop</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Main context.  
 <a href="classGlib_1_1MainContext.html#details">More...</a></p>

<p><code>#include &lt;glibmm/main.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d00f1f72f13112f5f3f92131440ecc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a9d00f1f72f13112f5f3f92131440ecc9">CppObjectType</a> = <a class="el" href="classGlib_1_1MainContext.html">Glib::MainContext</a></td></tr>
<tr class="separator:a9d00f1f72f13112f5f3f92131440ecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4bb57732aa1301e45a0a676cbfc079"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#abe4bb57732aa1301e45a0a676cbfc079">BaseObjectType</a> = GMainContext</td></tr>
<tr class="separator:abe4bb57732aa1301e45a0a676cbfc079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8eaedd89e2b7404ea364b2f8b4dfa0af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8eaedd89e2b7404ea364b2f8b4dfa0af">MainContext</a> (const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &amp; other)=delete</td></tr>
<tr class="separator:a8eaedd89e2b7404ea364b2f8b4dfa0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112cc935c448383449b568056d806db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a112cc935c448383449b568056d806db6">operator=</a> (const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &amp; other)=delete</td></tr>
<tr class="separator:a112cc935c448383449b568056d806db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde2e29315da1239af998f1826ad5e88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#afde2e29315da1239af998f1826ad5e88">iteration</a> (bool may_block)</td></tr>
<tr class="memdesc:afde2e29315da1239af998f1826ad5e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a single iteration for the given main loop.  <a href="classGlib_1_1MainContext.html#afde2e29315da1239af998f1826ad5e88">More...</a><br /></td></tr>
<tr class="separator:afde2e29315da1239af998f1826ad5e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#acf4631ab57318f39f3e15d98ac1aaa5c">pending</a> ()</td></tr>
<tr class="memdesc:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any sources have pending events for the given context.  <a href="classGlib_1_1MainContext.html#acf4631ab57318f39f3e15d98ac1aaa5c">More...</a><br /></td></tr>
<tr class="separator:acf4631ab57318f39f3e15d98ac1aaa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e60018f7549f064e71b34b1668020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a5a5e60018f7549f064e71b34b1668020">wakeup</a> ()</td></tr>
<tr class="memdesc:a5a5e60018f7549f064e71b34b1668020"><td class="mdescLeft">&#160;</td><td class="mdescRight">If context is currently waiting in a poll(), interrupt the poll(), and continue the iteration process.  <a href="classGlib_1_1MainContext.html#a5a5e60018f7549f064e71b34b1668020">More...</a><br /></td></tr>
<tr class="separator:a5a5e60018f7549f064e71b34b1668020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc">acquire</a> ()</td></tr>
<tr class="memdesc:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context.  <a href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc">More...</a><br /></td></tr>
<tr class="separator:aa92ee9cfb192aa5eb6c2aa0841068bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a68c3d19af76d4b32aeae9d2e4f5c230f">wait</a> (<a class="el" href="classGlib_1_1Cond.html">Glib::Cond</a> &amp; cond, <a class="el" href="classGlib_1_1Mutex.html">Glib::Mutex</a> &amp; mutex)</td></tr>
<tr class="memdesc:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>.  <a href="classGlib_1_1MainContext.html#a68c3d19af76d4b32aeae9d2e4f5c230f">More...</a><br /></td></tr>
<tr class="separator:a68c3d19af76d4b32aeae9d2e4f5c230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb4cc661f4f5773138a733f4a2ed156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#abbb4cc661f4f5773138a733f4a2ed156">wait</a> (<a class="el" href="classGlib_1_1Threads_1_1Cond.html">Glib::Threads::Cond</a> &amp; cond, <a class="el" href="classGlib_1_1Threads_1_1Mutex.html">Glib::Threads::Mutex</a> &amp; mutex)</td></tr>
<tr class="memdesc:abbb4cc661f4f5773138a733f4a2ed156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>.  <a href="classGlib_1_1MainContext.html#abbb4cc661f4f5773138a733f4a2ed156">More...</a><br /></td></tr>
<tr class="separator:abbb4cc661f4f5773138a733f4a2ed156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d9cdfa27cbe30026932de0526f730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730">release</a> ()</td></tr>
<tr class="memdesc:ace2d9cdfa27cbe30026932de0526f730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of a context previously acquired by this thread with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>.  <a href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730">More...</a><br /></td></tr>
<tr class="separator:ace2d9cdfa27cbe30026932de0526f730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#af6d1fccb3c1f5aab758d5eb1b3c15d6a">prepare</a> (int &amp; priority)</td></tr>
<tr class="memdesc:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to poll sources within a main loop.  <a href="classGlib_1_1MainContext.html#af6d1fccb3c1f5aab758d5eb1b3c15d6a">More...</a><br /></td></tr>
<tr class="separator:af6d1fccb3c1f5aab758d5eb1b3c15d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1bdf8fcb0130152237e87942c89ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#abd1bdf8fcb0130152237e87942c89ee1">prepare</a> ()</td></tr>
<tr class="memdesc:abd1bdf8fcb0130152237e87942c89ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to poll sources within a main loop.  <a href="classGlib_1_1MainContext.html#abd1bdf8fcb0130152237e87942c89ee1">More...</a><br /></td></tr>
<tr class="separator:abd1bdf8fcb0130152237e87942c89ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e8976cec1ae4f5b5c30feea6094927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927">query</a> (int max_priority, int &amp; timeout, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07721.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt; &amp; fds)</td></tr>
<tr class="memdesc:a49e8976cec1ae4f5b5c30feea6094927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines information necessary to poll this main loop.  <a href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927">More...</a><br /></td></tr>
<tr class="separator:a49e8976cec1ae4f5b5c30feea6094927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8061ef816d51cc27372f016c683cc513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8061ef816d51cc27372f016c683cc513">check</a> (int max_priority, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07721.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt; &amp; fds)</td></tr>
<tr class="memdesc:a8061ef816d51cc27372f016c683cc513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes the results of polling back to the main loop.  <a href="classGlib_1_1MainContext.html#a8061ef816d51cc27372f016c683cc513">More...</a><br /></td></tr>
<tr class="separator:a8061ef816d51cc27372f016c683cc513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a5c1f06dbac3bbf771c25ce76af0d4880">dispatch</a> ()</td></tr>
<tr class="memdesc:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches all pending sources.  <a href="classGlib_1_1MainContext.html#a5c1f06dbac3bbf771c25ce76af0d4880">More...</a><br /></td></tr>
<tr class="separator:a5c1f06dbac3bbf771c25ce76af0d4880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ad8383c8f1a1a03b904f9be608ad8eaaf">set_poll_func</a> (GPollFunc poll_func)</td></tr>
<tr class="memdesc:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to use to handle polling of file descriptors.  <a href="classGlib_1_1MainContext.html#ad8383c8f1a1a03b904f9be608ad8eaaf">More...</a><br /></td></tr>
<tr class="separator:ad8383c8f1a1a03b904f9be608ad8eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a0b1e31173e163f11053dbcf21b84c"><td class="memItemLeft" align="right" valign="top">GPollFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a34a0b1e31173e163f11053dbcf21b84c">get_poll_func</a> ()</td></tr>
<tr class="memdesc:a34a0b1e31173e163f11053dbcf21b84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the poll function set by g_main_context_set_poll_func().  <a href="classGlib_1_1MainContext.html#a34a0b1e31173e163f11053dbcf21b84c">More...</a><br /></td></tr>
<tr class="separator:a34a0b1e31173e163f11053dbcf21b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdbe7d102a781b6aded3cdda45fef34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a7cdbe7d102a781b6aded3cdda45fef34">add_poll</a> (<a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &amp; fd, int priority)</td></tr>
<tr class="memdesc:a7cdbe7d102a781b6aded3cdda45fef34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file descriptor to the set of file descriptors polled for this context.  <a href="classGlib_1_1MainContext.html#a7cdbe7d102a781b6aded3cdda45fef34">More...</a><br /></td></tr>
<tr class="separator:a7cdbe7d102a781b6aded3cdda45fef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ea2db49dd93739599d19756c251627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a33ea2db49dd93739599d19756c251627">remove_poll</a> (<a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &amp; fd)</td></tr>
<tr class="memdesc:a33ea2db49dd93739599d19756c251627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes file descriptor from the set of file descriptors to be polled for a particular context.  <a href="classGlib_1_1MainContext.html#a33ea2db49dd93739599d19756c251627">More...</a><br /></td></tr>
<tr class="separator:a33ea2db49dd93739599d19756c251627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95db3d8eb55ea7e754a8f638ffee3a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a95db3d8eb55ea7e754a8f638ffee3a1e">push_thread_default</a> ()</td></tr>
<tr class="memdesc:a95db3d8eb55ea7e754a8f638ffee3a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the context and sets it as the thread-default context for the current thread.  <a href="classGlib_1_1MainContext.html#a95db3d8eb55ea7e754a8f638ffee3a1e">More...</a><br /></td></tr>
<tr class="separator:a95db3d8eb55ea7e754a8f638ffee3a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043356f3d346004f7c5e057338426e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a043356f3d346004f7c5e057338426e32">pop_thread_default</a> ()</td></tr>
<tr class="memdesc:a043356f3d346004f7c5e057338426e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the context off the thread-default context stack (verifying that it was on the top of the stack).  <a href="classGlib_1_1MainContext.html#a043356f3d346004f7c5e057338426e32">More...</a><br /></td></tr>
<tr class="separator:a043356f3d346004f7c5e057338426e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51154582ff342993ff27fa0024ab38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f">invoke</a> (const <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/classsigc_1_1slot.html">sigc::slot</a>&lt; bool &gt; &amp; slot, int priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ab51154582ff342993ff27fa0024ab38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a function in such a way that this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> is owned during the invocation of <em>slot</em>.  <a href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f">More...</a><br /></td></tr>
<tr class="separator:ab51154582ff342993ff27fa0024ab38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf307c9028858449e932f5fff100d432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalTimeout.html">SignalTimeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#adf307c9028858449e932f5fff100d432">signal_timeout</a> ()</td></tr>
<tr class="memdesc:adf307c9028858449e932f5fff100d432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.  <a href="classGlib_1_1MainContext.html#adf307c9028858449e932f5fff100d432">More...</a><br /></td></tr>
<tr class="separator:adf307c9028858449e932f5fff100d432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a12990fb67f7b5c1ed61e36952dd827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalIdle.html">SignalIdle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a2a12990fb67f7b5c1ed61e36952dd827">signal_idle</a> ()</td></tr>
<tr class="memdesc:a2a12990fb67f7b5c1ed61e36952dd827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.  <a href="classGlib_1_1MainContext.html#a2a12990fb67f7b5c1ed61e36952dd827">More...</a><br /></td></tr>
<tr class="separator:a2a12990fb67f7b5c1ed61e36952dd827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalIO.html">SignalIO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a8c8a4283456eb9036cc09dc3aaf203dc">signal_io</a> ()</td></tr>
<tr class="memdesc:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.  <a href="classGlib_1_1MainContext.html#a8c8a4283456eb9036cc09dc3aaf203dc">More...</a><br /></td></tr>
<tr class="separator:a8c8a4283456eb9036cc09dc3aaf203dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1SignalChildWatch.html">SignalChildWatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ab646f19ce79faa35d97e8af93e6ca6d6">signal_child_watch</a> ()</td></tr>
<tr class="memdesc:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">child watch signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.  <a href="classGlib_1_1MainContext.html#ab646f19ce79faa35d97e8af93e6ca6d6">More...</a><br /></td></tr>
<tr class="separator:ab646f19ce79faa35d97e8af93e6ca6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae152285f41828d272c02ebe683c0d0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ae152285f41828d272c02ebe683c0d0d0">reference</a> () const</td></tr>
<tr class="separator:ae152285f41828d272c02ebe683c0d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612d2ceca28cb1a7e41283bb8d7f798f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a612d2ceca28cb1a7e41283bb8d7f798f">unreference</a> () const</td></tr>
<tr class="separator:a612d2ceca28cb1a7e41283bb8d7f798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbf5178aca208161051097f034d3694"><td class="memItemLeft" align="right" valign="top">GMainContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a0fbf5178aca208161051097f034d3694">gobj</a> ()</td></tr>
<tr class="separator:a0fbf5178aca208161051097f034d3694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bda857b2cb48321b92ea26302a19b5"><td class="memItemLeft" align="right" valign="top">const GMainContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#ad9bda857b2cb48321b92ea26302a19b5">gobj</a> () const</td></tr>
<tr class="separator:ad9bda857b2cb48321b92ea26302a19b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ea5601091628af19ab583979064b6b"><td class="memItemLeft" align="right" valign="top">GMainContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a48ea5601091628af19ab583979064b6b">gobj_copy</a> () const</td></tr>
<tr class="separator:a48ea5601091628af19ab583979064b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31bd96bf707a21c8a3003337dd3af9c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a31bd96bf707a21c8a3003337dd3af9c4">create</a> ()</td></tr>
<tr class="memdesc:a31bd96bf707a21c8a3003337dd3af9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.  <a href="classGlib_1_1MainContext.html#a31bd96bf707a21c8a3003337dd3af9c4">More...</a><br /></td></tr>
<tr class="separator:a31bd96bf707a21c8a3003337dd3af9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502cbed045a9fb27d18c6975e1d255d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a1502cbed045a9fb27d18c6975e1d255d">get_default</a> ()</td></tr>
<tr class="memdesc:a1502cbed045a9fb27d18c6975e1d255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global default main context.  <a href="classGlib_1_1MainContext.html#a1502cbed045a9fb27d18c6975e1d255d">More...</a><br /></td></tr>
<tr class="separator:a1502cbed045a9fb27d18c6975e1d255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9714d3137b0379d39fa9bd1bd9e916a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1MainContext.html#a9714d3137b0379d39fa9bd1bd9e916a1">get_thread_default</a> ()</td></tr>
<tr class="memdesc:a9714d3137b0379d39fa9bd1bd9e916a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread-default <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> for this thread.  <a href="classGlib_1_1MainContext.html#a9714d3137b0379d39fa9bd1bd9e916a1">More...</a><br /></td></tr>
<tr class="separator:a9714d3137b0379d39fa9bd1bd9e916a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ga043c5714afbad2745b27301dd58470a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainLoop.html#ga043c5714afbad2745b27301dd58470a4">wrap</a> (GMainContext * gobject, bool take_copy=false)</td></tr>
<tr class="separator:ga043c5714afbad2745b27301dd58470a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main context. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abe4bb57732aa1301e45a0a676cbfc079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4bb57732aa1301e45a0a676cbfc079">&#9670;&#160;</a></span>BaseObjectType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classGlib_1_1MainContext.html#abe4bb57732aa1301e45a0a676cbfc079">Glib::MainContext::BaseObjectType</a> =  GMainContext</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d00f1f72f13112f5f3f92131440ecc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d00f1f72f13112f5f3f92131440ecc9">&#9670;&#160;</a></span>CppObjectType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classGlib_1_1MainContext.html#a9d00f1f72f13112f5f3f92131440ecc9">Glib::MainContext::CppObjectType</a> =  <a class="el" href="classGlib_1_1MainContext.html">Glib::MainContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8eaedd89e2b7404ea364b2f8b4dfa0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eaedd89e2b7404ea364b2f8b4dfa0af">&#9670;&#160;</a></span>MainContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::MainContext::MainContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa92ee9cfb192aa5eb6c2aa0841068bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92ee9cfb192aa5eb6c2aa0841068bbc">&#9670;&#160;</a></span>acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context. </p>
<p>If some other thread is the owner of the context, returns <code>false</code> immediately. Ownership is properly recursive: the owner can require ownership again and will release ownership when <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire().">release()</a> is called as many times as <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>. You must be the owner of a context before you can call <a class="el" href="classGlib_1_1MainContext.html#abd1bdf8fcb0130152237e87942c89ee1" title="Prepares to poll sources within a main loop.">prepare()</a>, <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop.">query()</a>, <a class="el" href="classGlib_1_1MainContext.html#a8061ef816d51cc27372f016c683cc513" title="Passes the results of polling back to the main loop.">check()</a>, <a class="el" href="classGlib_1_1MainContext.html#a5c1f06dbac3bbf771c25ce76af0d4880" title="Dispatches all pending sources.">dispatch()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context. </dd></dl>

</div>
</div>
<a id="a7cdbe7d102a781b6aded3cdda45fef34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdbe7d102a781b6aded3cdda45fef34">&#9670;&#160;</a></span>add_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::add_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &amp;&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file descriptor to the set of file descriptors polled for this context. </p>
<p>This will very seldomly be used directly. Instead a typical event source will use <a class="el" href="classGlib_1_1Source.html#a3a0843a960cad7a25919a682c37c9d03" title="Adds a file descriptor to the set of file descriptors polled for this source.">Glib::Source::add_poll()</a> instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> structure holding information about a file descriptor to watch. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority for this file descriptor which should be the same as the priority used for <a class="el" href="classGlib_1_1Source.html#a77c4b83960b2fd8d65b10ade1fc2e2fb" title="Adds a Source to a context so that it will be executed within that context.">Glib::Source::attach()</a> to ensure that the file descriptor is polled whenever the results may be needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8061ef816d51cc27372f016c683cc513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8061ef816d51cc27372f016c683cc513">&#9670;&#160;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::check </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07721.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes the results of polling back to the main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_priority</td><td>Maximum numerical priority of sources to check. </td></tr>
    <tr><td class="paramname">fds</td><td>Vector of <a class="el" href="classGlib_1_1PollFD.html">Glib::PollFD</a>'s that was passed to the last call to <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop.">query()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some sources are ready to be dispatched. </dd></dl>

</div>
</div>
<a id="a31bd96bf707a21c8a3003337dd3af9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bd96bf707a21c8a3003337dd3af9c4">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&gt; Glib::MainContext::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The new <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </dd></dl>

</div>
</div>
<a id="a5c1f06dbac3bbf771c25ce76af0d4880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1f06dbac3bbf771c25ce76af0d4880">&#9670;&#160;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::dispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatches all pending sources. </p>

</div>
</div>
<a id="a1502cbed045a9fb27d18c6975e1d255d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1502cbed045a9fb27d18c6975e1d255d">&#9670;&#160;</a></span>get_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&gt; Glib::MainContext::get_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the global default main context. </p>
<p>This is the main context used for main loop functions when a main loop is not explicitly specified, and corresponds to the "main" main loop.</p>
<dl class="section return"><dt>Returns</dt><dd>The global default main context. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGlib_1_1MainContext.html#a9714d3137b0379d39fa9bd1bd9e916a1" title="Gets the thread-default MainContext for this thread.">get_thread_default()</a> </dd></dl>

</div>
</div>
<a id="a34a0b1e31173e163f11053dbcf21b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a0b1e31173e163f11053dbcf21b84c">&#9670;&#160;</a></span>get_poll_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GPollFunc Glib::MainContext::get_poll_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the poll function set by g_main_context_set_poll_func(). </p>
<dl class="section return"><dt>Returns</dt><dd>The poll function </dd></dl>

</div>
</div>
<a id="a9714d3137b0379d39fa9bd1bd9e916a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9714d3137b0379d39fa9bd1bd9e916a1">&#9670;&#160;</a></span>get_thread_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&gt; Glib::MainContext::get_thread_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the thread-default <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> for this thread. </p>
<p>Asynchronous operations that want to be able to be run in contexts other than the default one should call this method to get a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> to add their Glib::Sources to. (Note that even in single-threaded programs applications may sometimes want to temporarily push a non-default context, so it is not safe to assume that this will always return the global default context if you are running in the default thread.)</p>
<p>This method wraps g_main_context_ref_thread_default(), and not g_main_context_get_thread_default().</p>
<dl class="section return"><dt>Returns</dt><dd>The thread-default <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>.</dd></dl>
<dl class="since_2_64"><dt><b><a class="el" href="since_2_64.html#_since_2_64000003">Since glibmm 2.64:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a0fbf5178aca208161051097f034d3694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbf5178aca208161051097f034d3694">&#9670;&#160;</a></span>gobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GMainContext* Glib::MainContext::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9bda857b2cb48321b92ea26302a19b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bda857b2cb48321b92ea26302a19b5">&#9670;&#160;</a></span>gobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GMainContext* Glib::MainContext::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48ea5601091628af19ab583979064b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ea5601091628af19ab583979064b6b">&#9670;&#160;</a></span>gobj_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GMainContext* Glib::MainContext::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab51154582ff342993ff27fa0024ab38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51154582ff342993ff27fa0024ab38f">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/classsigc_1_1slot.html">sigc::slot</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes a function in such a way that this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> is owned during the invocation of <em>slot</em>. </p>
<p>If the context is owned by the current thread, <em>slot</em> is called directly. Otherwise, if the context is the thread-default main context of the current thread and <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a> succeeds, then <em>slot</em> is called and <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire().">release()</a> is called afterwards.</p>
<p>In any other case, an idle source is created to call <em>slot</em> and that source is attached to the context (presumably to be run in another thread).</p>
<p>Note that, as with normal idle functions, <em>slot</em> should probably return <code>false</code>. If it returns <code>true</code>, it will be continuously run in a loop (and may prevent this call from returning).</p>
<p>If an idle source is created to call <em>slot</em>, <a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f" title="Invokes a function in such a way that this MainContext is owned during the invocation of slot.">invoke()</a> may return before <em>slot</em> is called.</p>
<p>Because <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/structsigc_1_1trackable.html">sigc::trackable</a> is not thread-safe, if the slot represents a non-static method of a class deriving from <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/structsigc_1_1trackable.html">sigc::trackable</a>, and the slot is created by <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/namespacesigc.html#gaeef6e55681664df29b31edec51ea034d">sigc::mem_fun()</a>, <a class="el" href="classGlib_1_1MainContext.html#ab51154582ff342993ff27fa0024ab38f" title="Invokes a function in such a way that this MainContext is owned during the invocation of slot.">invoke()</a> should only be called from the thread where the context runs. You can use, say, boost::bind() or, in C++11, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01598.html#gaa9daf91054406729e4056b602dde4fc1">std::bind()</a> or a C++11 lambda expression instead of <a class="elRef" href="http://library.gnome.org/devel/libsigc++/2.10/namespacesigc.html#gaeef6e55681664df29b31edec51ea034d">sigc::mem_fun()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A slot to call. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the idle source, if one is created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000001">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="afde2e29315da1239af998f1826ad5e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde2e29315da1239af998f1826ad5e88">&#9670;&#160;</a></span>iteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::iteration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>may_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a single iteration for the given main loop. </p>
<p>This involves checking to see if any event sources are ready to be processed, then if no events sources are ready and may_block is true, waiting for a source to become ready, then dispatching the highest priority events sources that are ready. Note that even when may_block is true, it is still possible for <a class="el" href="classGlib_1_1MainContext.html#afde2e29315da1239af998f1826ad5e88" title="Runs a single iteration for the given main loop.">iteration()</a> to return false, since the the wait may be interrupted for other reasons than an event source becoming ready. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">may_block</td><td>Whether the call may block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if events were dispatched. </dd></dl>

</div>
</div>
<a id="a112cc935c448383449b568056d806db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112cc935c448383449b568056d806db6">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1MainContext.html">MainContext</a>&amp; Glib::MainContext::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1MainContext.html">MainContext</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf4631ab57318f39f3e15d98ac1aaa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4631ab57318f39f3e15d98ac1aaa5c">&#9670;&#160;</a></span>pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::pending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any sources have pending events for the given context. </p>
<dl class="section return"><dt>Returns</dt><dd>true if events are pending. </dd></dl>

</div>
</div>
<a id="a043356f3d346004f7c5e057338426e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043356f3d346004f7c5e057338426e32">&#9670;&#160;</a></span>pop_thread_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::pop_thread_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the context off the thread-default context stack (verifying that it was on the top of the stack). </p>
<dl class="since_2_64"><dt><b><a class="el" href="since_2_64.html#_since_2_64000002">Since glibmm 2.64:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="abd1bdf8fcb0130152237e87942c89ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1bdf8fcb0130152237e87942c89ee1">&#9670;&#160;</a></span>prepare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares to poll sources within a main loop. </p>
<p>The resulting information for polling is determined by calling <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop.">query()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if some source is ready to be dispatched prior to polling. </dd></dl>

</div>
</div>
<a id="af6d1fccb3c1f5aab758d5eb1b3c15d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d1fccb3c1f5aab758d5eb1b3c15d6a">&#9670;&#160;</a></span>prepare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::prepare </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares to poll sources within a main loop. </p>
<p>The resulting information for polling is determined by calling <a class="el" href="classGlib_1_1MainContext.html#a49e8976cec1ae4f5b5c30feea6094927" title="Determines information necessary to poll this main loop.">query()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>Location to store priority of highest priority source already ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some source is ready to be dispatched prior to polling. </dd></dl>

</div>
</div>
<a id="a95db3d8eb55ea7e754a8f638ffee3a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95db3d8eb55ea7e754a8f638ffee3a1e">&#9670;&#160;</a></span>push_thread_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::push_thread_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the context and sets it as the thread-default context for the current thread. </p>
<p>This will cause certain asynchronous operations (such as most gio-based I/O) which are started in this thread to run under this context and deliver their results to its main loop, rather than running under the global default context in the main thread. Note that calling this function changes the context returned by <a class="el" href="classGlib_1_1MainContext.html#a9714d3137b0379d39fa9bd1bd9e916a1" title="Gets the thread-default MainContext for this thread.">get_thread_default()</a>, not the one returned by <a class="el" href="classGlib_1_1MainContext.html#a1502cbed045a9fb27d18c6975e1d255d" title="Returns the global default main context.">get_default()</a>, so it does not affect the context used by functions like g_idle_add().</p>
<p>Normally you would call this function shortly after creating a new thread, passing it a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> which will be run by a <a class="el" href="classGlib_1_1MainLoop.html">Glib::MainLoop</a> in that thread, to set a new default context for all async operations in that thread. In this case you may not need to ever call <a class="el" href="classGlib_1_1MainContext.html#a043356f3d346004f7c5e057338426e32" title="Pops the context off the thread-default context stack (verifying that it was on the top of the stack)...">pop_thread_default()</a>, assuming you want the new <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> to be the default for the whole lifecycle of the thread.</p>
<p>If you don't have control over how the new thread was created (e.g. if the new thread isn't newly created, or if the thread life cycle is managed by a GThreadPool), it is always suggested to wrap the logic that needs to use the new <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> inside a <a class="el" href="classGlib_1_1MainContext.html#a95db3d8eb55ea7e754a8f638ffee3a1e" title="Acquires the context and sets it as the thread-default context for the current thread.">push_thread_default()</a> / <a class="el" href="classGlib_1_1MainContext.html#a043356f3d346004f7c5e057338426e32" title="Pops the context off the thread-default context stack (verifying that it was on the top of the stack)...">pop_thread_default()</a> pair, otherwise threads that are re-used will end up never explicitly releasing the <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> reference they hold.</p>
<p>In some cases you may want to schedule a single operation in a non-default context, or temporarily use a non-default context in the main thread. In that case, you can wrap the call to the asynchronous operation inside a <a class="el" href="classGlib_1_1MainContext.html#a95db3d8eb55ea7e754a8f638ffee3a1e" title="Acquires the context and sets it as the thread-default context for the current thread.">push_thread_default()</a> / <a class="el" href="classGlib_1_1MainContext.html#a043356f3d346004f7c5e057338426e32" title="Pops the context off the thread-default context stack (verifying that it was on the top of the stack)...">pop_thread_default()</a> pair, but it is up to you to ensure that no other asynchronous operations accidentally get started while the non-default context is active.</p>
<p>Beware that libraries that predate this function may not correctly handle being used from a thread with a thread-default context. Eg, see <a class="el" href="classGio_1_1File.html#a33fe9221d11bc78619ce08424b924680" title="Checks if file supports [thread-default contexts][g-main-context-push-thread-default-context].">Gio::File::supports_thread_contexts()</a>.</p>
<dl class="since_2_64"><dt><b><a class="el" href="since_2_64.html#_since_2_64000001">Since glibmm 2.64:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a49e8976cec1ae4f5b5c30feea6094927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e8976cec1ae4f5b5c30feea6094927">&#9670;&#160;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::query </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a07721.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines information necessary to poll this main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_priority</td><td>Maximum priority source to check. </td></tr>
    <tr><td class="paramname">timeout</td><td>Location to store timeout to be used in polling. </td></tr>
    <tr><td class="paramname">fds</td><td>Location to store <a class="el" href="classGlib_1_1PollFD.html">Glib::PollFD</a> records that need to be polled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of records actually stored in fds, or, if more than n_fds records need to be stored, the number of records that need to be stored. </dd></dl>

</div>
</div>
<a id="ae152285f41828d272c02ebe683c0d0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae152285f41828d272c02ebe683c0d0d0">&#9670;&#160;</a></span>reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2d9cdfa27cbe30026932de0526f730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2d9cdfa27cbe30026932de0526f730">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases ownership of a context previously acquired by this thread with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>. </p>
<p>If the context was acquired multiple times, the only release ownership when <a class="el" href="classGlib_1_1MainContext.html#ace2d9cdfa27cbe30026932de0526f730" title="Releases ownership of a context previously acquired by this thread with acquire().">release()</a> is called as many times as it was acquired. </p>

</div>
</div>
<a id="a33ea2db49dd93739599d19756c251627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ea2db49dd93739599d19756c251627">&#9670;&#160;</a></span>remove_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::remove_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1PollFD.html">PollFD</a> &amp;&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes file descriptor from the set of file descriptors to be polled for a particular context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A <a class="el" href="classGlib_1_1PollFD.html">PollFD</a> structure holding information about a file descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8383c8f1a1a03b904f9be608ad8eaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8383c8f1a1a03b904f9be608ad8eaaf">&#9670;&#160;</a></span>set_poll_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::set_poll_func </td>
          <td>(</td>
          <td class="paramtype">GPollFunc&#160;</td>
          <td class="paramname"><em>poll_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the function to use to handle polling of file descriptors. </p>
<p>It will be used instead of the poll() system call (or GLib's replacement function, which is used where poll() isn't available). This function could possibly be used to integrate the GLib event loop with an external event loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll_func</td><td>The function to call to poll all file descriptors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab646f19ce79faa35d97e8af93e6ca6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab646f19ce79faa35d97e8af93e6ca6d6">&#9670;&#160;</a></span>signal_child_watch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalChildWatch.html">SignalChildWatch</a> Glib::MainContext::signal_child_watch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>child watch signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalChildWatch.html#a4c2f5be316b9600133129cc974b6b5bb" title="Connects a child watch handler.">SignalChildWatch::connect()</a>. </dd></dl>

</div>
</div>
<a id="a2a12990fb67f7b5c1ed61e36952dd827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12990fb67f7b5c1ed61e36952dd827">&#9670;&#160;</a></span>signal_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalIdle.html">SignalIdle</a> Glib::MainContext::signal_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idle signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalIdle.html#ac8befbaf1d10a17d1f3f75143e967a3f" title="Connects an idle handler.">SignalIdle::connect()</a>. </dd></dl>

</div>
</div>
<a id="a8c8a4283456eb9036cc09dc3aaf203dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8a4283456eb9036cc09dc3aaf203dc">&#9670;&#160;</a></span>signal_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalIO.html">SignalIO</a> Glib::MainContext::signal_io </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalIO.html#af4ffeaefbe8ca44b567314fadfd4760e" title="Connects an I/O handler that watches a file descriptor.">SignalIO::connect()</a>. </dd></dl>

</div>
</div>
<a id="adf307c9028858449e932f5fff100d432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf307c9028858449e932f5fff100d432">&#9670;&#160;</a></span>signal_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1SignalTimeout.html">SignalTimeout</a> Glib::MainContext::signal_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout signal, attached to this <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A signal proxy; you want to use <a class="el" href="classGlib_1_1SignalTimeout.html#a75b555ed13d91e6903e927f9e0d7afd2" title="Connects a timeout handler.">SignalTimeout::connect()</a>. </dd></dl>

</div>
</div>
<a id="a612d2ceca28cb1a7e41283bb8d7f798f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612d2ceca28cb1a7e41283bb8d7f798f">&#9670;&#160;</a></span>unreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::unreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68c3d19af76d4b32aeae9d2e4f5c230f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c3d19af76d4b32aeae9d2e4f5c230f">&#9670;&#160;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Cond.html">Glib::Cond</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Mutex.html">Glib::Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>. </p>
<p>But if another thread is the owner, atomically drop mutex and wait on cond until that owner releases ownership or until cond is signaled, then try again (once) to become the owner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable. </td></tr>
    <tr><td class="paramname">mutex</td><td>A mutex, currently held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use the underlying g_main_context_is_owner() function and separate locking, if you really need this functionality. </dd></dl>

</div>
</div>
<a id="abbb4cc661f4f5773138a733f4a2ed156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb4cc661f4f5773138a733f4a2ed156">&#9670;&#160;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::MainContext::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Threads_1_1Cond.html">Glib::Threads::Cond</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1Threads_1_1Mutex.html">Glib::Threads::Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to become the owner of the specified context, as with <a class="el" href="classGlib_1_1MainContext.html#aa92ee9cfb192aa5eb6c2aa0841068bbc" title="Tries to become the owner of the specified context.">acquire()</a>. </p>
<p>But if another thread is the owner, atomically drop mutex and wait on cond until that owner releases ownership or until cond is signaled, then try again (once) to become the owner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>A condition variable. </td></tr>
    <tr><td class="paramname">mutex</td><td>A mutex, currently held. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation succeeded, and this thread is now the owner of context.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use the underlying g_main_context_is_owner() function and separate locking, if you really need this functionality. </dd></dl>

</div>
</div>
<a id="a5a5e60018f7549f064e71b34b1668020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5e60018f7549f064e71b34b1668020">&#9670;&#160;</a></span>wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::MainContext::wakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If context is currently waiting in a poll(), interrupt the poll(), and continue the iteration process. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 5 2021 15:38:10 for glibmm by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
